Ελευθέριος Μπόλκας 1115201900353

Περιεχόμενα:
Τα αρχεία κειμένου countriesFile, virusFile, inputFile(αυτό παράγεται από το bash script), το bash script  testFile.sh, το Makefile, το README.txt, τα αρχεία πηγαίου κώδικα helpfulStringFunctions.cpp, vaccapp.cpp με τα ανίστοιχα headers τους, το vaccineMonitor.cpp που περιέχει τη main και οι φάκελοι BloomFilter,Date_citizen_country, OtherLists, SkipList. Ο φάκελος BloomFilter περιέχει το bloomfilter.cpp με το αντίστοιχο header του, ο Date_citizen_country το date_citizen_country.cpp με το αντίστοιχο header του, ο SkipList το skiplist.cpp με το αντίστοιχο header του και ο OtherLists τα countryList.cpp, statList.cpp και virusList.cpp με τα ανίστοιχα headers τους.

Compilation της εφαρμογής:
Από το κεντρικό directory στο οποίο βρίσκεται και το Makefile εκτελούμε την make. Γίνεται separate compilation και στο τέλος μέσω του linker δημιουργείται το εκτελέσιμο vaccineMonitor.

Εκτέλεση προγράμματος:
./vaccineMonitor -c citizenRecordsFile –b bloomSize
Στη θέση του citizenRecordsFile μπαίνει το inputFile στην περίπτωση που θέλουμε να πάρουμε τα δεδομένα από το αρχείο που παράγεται από το bash script.

Εκτέλεση του Bash script:
./testFile.sh virusesFile countriesFile numLines duplicatesAllowed

Η εφαρμογή:
Στο αρχεία date_citizen_country.h, date_citizen_country.cpp έχουν οριστεί και υλοποιηθεί μια κλάση date που αναπαριστά μια ημερομηνία, ένα struct country που αναπαριστά μια χώρα, ένα struct citizen που αναπαριστά έναν πολίτη και περιέχει όλες τις πληροφορίες γι' αυτόν συμπεριλαμβανομένου ενός δείκτη σε country για τη χώρα του και ένα struct citizenANDdate. Το τελευταίο αποτελεί ένα αντικείμενο που αποτελείται από ένα δείκτη σε citizen και μία date και χρησιμεύει για να ενοποιήσουμε τις δύο αυτές πληροφορίες σε ένα αντικείμενο, όταν αυτό χρειάζεται για τεχνικούς λόγους.

Για την εφαρμογή έχουν υλοποιηθεί ένα BloomFilter, μία SkipList και 3 είδη συνδεδεμένων λιστών. 

Το BloomFilter υλοποιείται από μία κλάση BloomFilter η οποία μεταξύ των μελών-πεδίων της έχει ένα array που είναι δείκτης σε unsigned char. Καθώς κάθε unsigned char αποτελείται 8 bits, αν το μέγεθος του array είναι bloomSize, τότε αυτό φυλάσσει 8*bloomSize bits. Αυτά τα 8*bloomSize bits απότελούν τις θέσεις του πίνακα του BloomFilter που περιγράφεται στην εκφώνηση και για να έχουμε πρόσβαση στη θέση Χ του πίνακα, όπου Χ=Π*8+Υ, πάμε στο array[Π] και βρίσκουμε το bit στη θέση Υ, ξεκινώντας από το most significant bit. Έτσι με χρήση κατάλληλων bit operator και των hash function υλοποιούνται οι λειτουργίες εισαγωγής(Insert) και αναζήτησης(Search) του BloomFilter.

H SkipList υλοποιείται από την κλάση SkipList. Αυτή έχει εμφωλευμένη την struct SkipListNode, η οποία αναπαριστά έναν κόμβο της SkipList.  Κάθε επίπεδο της SkipList ξεκινάει με ένα SkipListNode το οποίο αποτελεί το head node αυτού του επιπέδου και ακολουθείται από άλλα SkipListNodes συνδεδεμένα μεταξύ τους. Κάθε επίπεδο αποτελεί ουσιαστικά μια ταξινομημένη διπλά συνδεδεμένη λίστα. Τα επίπεδα συνδέονται μεταξύ τους μέσω των κόμβων τους. 
Πιο συγκεκριμένα, η SkipList έχει ως πεδίο-μέλος της ένα δείκτη στο head node που είναι στο υψηλότερο επίπεδο και ένα δείκτη στο head node του χαμηλότερου επιπέδου της SkipList. Τόσα τα head nodes, όσο και οι απλοί κόμβοι της SkipList αναπαριστώνται από το SkipListNode. Στην περίπτωση ενός head, το πεδίο data στο SkipListNode έχει τιμή NULL, ενώ στους υπόλοιπους κόμβους έχει ένα δείκτη στον πολίτη(citizen) που αναπαριστά. Το SkipListNode περιλαμβάνει επίσης στα πεδία του ένα αντικείμενο date που έχει την ημερομηνία εμβολιασμού, όταν η SkipList περιέχει του εμβολιασμένους πολίτες ενός ιού. Αλλιώς, η ημερομηνία δεν χρειάζεται και αποθηκεύει την ημερομηνία 0-0-0. Ακόμα, το SkipListNode έχει ένα δείκτη next στο επόμενο SkipListNode του ίδιου επιπέδου και έναν prev στο προηγούμενο SkipListNode του ίδιου επιπέδου. Τέλος, περιλαμβάνει ένα δείκτη up στο SkipListNode που περιέχει τον ίδιο πολίτη του αμέσως υψηλότερου επιπέδου και ένα δείκτη down στο SkipListNode που περιέχει τον ίδιο πολίτη του αμέσως χαμηλότερου επιπέδου. Οι δείκτες έχουν τιμή NULL όταν δεν υπάρχει ο αναφερόμενος κόμβος, ενώ ειδικά όταν το next έχει τιμή NULL σημαίνει ότι ο κόμβος αυτός είναι ο τελευταίος αυτού του επιπέδου. Οι δείκτες up και down χρησιμοποιήθηκαν ώστε να μετακινούμαστε γρηγορότερα και ευκολότερα μεταξύ 2 επιπέδων κατά την υλοποίηση των μεθόδων της SkipList. Επιλέχθηκε το ID να μην αποθηκεύεται ξεχωριστά στο SkipListNode, αφού υπάρχει ήδη ως πληροφορία στον citizen και συνεπώς για τις απαιτούμενες συγκρίσεις διαβάζουμε το ID από εκεί.
Κατά την δημιουργία της SkipList περνιούνται ως παράμετροι ένα ποσοστό που αναφέρεται στο ποια είναι πιθανότητα να δημιουργηθεί ένα κόμβος στο επόμενο υψηολότερο επίπεδο κατά την εισαγωγή ενός στοιχείου(πολίτη) και ένας μέγιστος προσδοκώμενος αριθμός ατόμων που μπορεί να εισαχθεί στη SkipList. Ο τελευταίος αυτός αριθμός χρησιμεύει μόνο στο να ορίζουμε μέσω του λογαρίθμου του, ένα ανώτατο όριο στο ύψος που μπορεί να έχει η SkipList(max_height) με σκοπό να παραμένει αποδοτική. Η αναζήτηση(FindNode και Search) στη Skiplist γίνεται με τον αναμενόμενο τρόπο, ξεκινώντας από το υψηλότερο επίπεδο και καταβαίνοντας ένα επίπεδο κάθε φορά που βρίσκουμε την αμέσως μεγαλύτερη τιμή του στοιχείου που αναζητούμε στο επίπεδο αυτό. Όμοια η εισαγωγή(Insert) ενός στοιχείου γίνεται αναμενόμενα ξεκινώντας από το υψηλότερο επίπεδο και δουλεύοντας όπως στη Search, βρίσκουμε στο κατώτατο επίπεδο τη θέση στην οποία δημιουργούμε ένα SkipListNode με τον πολίτη που εισάγουμε. Τότε αποφασίζουμε τυχαία κάθε φορά αν θα δημιουργηθεί ένα SkipListNode με τον πολίτη στο αμέσως υψηλότερο επίπεδο(αν δεν υπάρχει ήδη αμέσως υψηλότερο επίπεδο, δημιουργούμε ένα νέο επίπεδο) μέχρι να επιλέξουμε αρνητικά. Η διαγραφή(Delete) υλοποιείται κι αυτή με παρόμοιο τρόπο ενώ και οι τρεις αυτές μέθοδοι έχουν πράγματι πολυπλοκότητα Ο(logn). Οι μέθοδοι UpdateStatList χρησιμεύουν στη δημιουργία στατιστικών και εξηγούνται παρακάτω στην ανάλυση της κλάσης VaccApp.

H κλάση CountryList αναπαριστά μία απλά συνδεδεμένη λίστα και χρησιμοποιείται για να αποθηκεύσει όλες τις χώρες που εισάγονται στην εφαρμογή. Για την αποθήκευση των χωρών προτιμήθηκε η υλοποίηση μίας απλής λίστας καθώς ο αριθμός των χωρών που υπάρχουν δεν είναι μεγάλος κι έτσι στην πραγματικότητα δεν επιβαρύνεται σημαντικά χρονικά η εφαρμογή. Για την υλοποίηση της χρησιμοποείται ένας κόμβος struct CountryListNode που είναι εμφωλευμένος ως μέλος στην κλάση CountryList.

Η κλάση VirusList είναι επίσης μια απλά συνδεδεμένη λίστα και αποθηκεύει τη λίστα με τους ιούς που εισήχθησαν στην εφαρμογή. Επίσης για κάθε ιό, αποθηκεύει από ένα δείκτη στο BloomFilter και στις δύο SkipLists που σχετίζονται με τον ιό. Συγκεκριμένα, κάθε κόμβος της λίστας αναπαρίσταται από ένα αντικείμενο τύπου struct VirusListNode. To struct αυτό είναι εμφωλευμένο ως μέλος στην VirusList. Κάθε VirusListNode αναφέρεται σε έναν ιό και η κλάση του έχει ως πεδία το όνομα του ιού, ένα δείκτη στο BloomFilter για τον ιό αυτό, ένα δείκτη στη SkipList με τους vaccinated persons του ιού αυτού και ένα δείκτη στη SkipList με τους not vaccinated persons αυτού του ιού. Έτσι, μέσω των μεθόδων της VirusList αποκτάμε πρόσβαση στην δομή που επιθυμούμε για τον ιό που μας ενδιαφέρει.

Η κλάση StatList αναπαριστά ακόμα μία απλά συνδεδεμένη λίστα και χρησιμοποιείται για τον υπολογισμό των στατιστικών που ζητούνται από τις εντολές /populationStatus και /popStatusByAge. Η StatList δημιουργείται προσωρινά μόνο όταν εκτελούνται οι παραπάνω εντολές μέσω μεθόδων της κλάσης VaccApp(αναλύεται παρακάτω όταν εξηγείται η VaccApp) και δεν παραμένει στη μνήμη κατά την υπόλοιπη διάρκεια της εκτέλεσης εφαρμογής. Υλοποιείται και αυτή με τη βοήθεια μια εμφωλευμένης struct StatCountryNode η οποία είναι μέλος της StatList. Κάθε StatCountryNode αποτελεί ένα κόμβο της λίστας StatList και αντιπροσωπεύει τα στατιστικά για μία χώρα. Συγκεκριμένα, η κλάση StatCountryNode έχει (μεταξύ άλλων) ως πεδία μέλη της το όνομα της χώρας, 4 ακεραίους VacAge*** για τις 4 ηλικιακές κατηγορίες και 4 ακεραίους nonVacAge*** πάλι για τις 4 ηλικιακές κατηγορίες. Στην περίπτωση που η StatList έχει δημιουργηθεί για υπολογισμό στατιστικών που αφορούν τους εμβολιασμένους μεταξύ δύο ημερομηνιών για έναν ιό, κάθε VacAge*** αποθηκεύει το πλήθος των εμβολιασμένων πολιτών μιας χώρας στην αντίστοιχη ηλικιακή κατηγορία κατά τη διάρκεια μιας χρονικής περιόδου και κάθε nonVacAge*** αποθηκεύει το άθροισμα του πλήθους των εμβολιασμένων πολιτών μιας χώρας σε αυτή την ηλικιακή κατηγορία εκτός αυτής της χρονικής περιόδου συν του πλήθους των μη εμβολιασμένων πολιτών της χώρας σε αυτή την ηλικιακή κατηγορία. Όμοια, στην περίπτωση που η StatList έχει δημιουργηθεί για υπολογισμό στατιστικών που αφορούν τους εμβολιασμένους για έναν ιό(χωρίς ημερομηνίες), κάθε VacAge*** αποθηκεύει το πλήθος των εμβολιασμένων πολιτών μιας χώρας στην αντίστοιχη ηλικιακή κατηγορία και κάθε nonVacAge*** αποθηκεύει το πλήθος των μη εμβολιασμένων πολιτών της χώρας σε αυτή την ηλικιακή κατηγορία. Οι 2 μέθοδοι PrintVac**** υπολογίζουν και τυπώνουν τα ζητούμενα από την εκφώνηση στατιστικά.

Στα αρχεία helpfulStringFunctions.cpp, helpfulStringFunctions.h έχουν υλοποιηθεί συναρτήσεις που βοηθούν στο να ελεγχθεί η ορθότητα των εντολών και των records που δίνονται από το χρήστη.

Η κλάση VaccApp συγκεντρώνει όλες τις δομές που χρειάζεται το πρόγραμμα για τη λειτουργία του και περιέχει μεθόδους που υλοποιούν όλες τις συμπεριφορές που απαιτούνται από τις εντολές που δέχεται η εφαρμογή. Συγκεκριμένα, στα μέλη-πεδία της περιλαμβάνει τη CList που είναι μια CountryList και περιέχει μια λίστα με όλες τις χώρες που έχουν εισαχθεί στην εφαρμογή. Επίσης, περιλαμβάνει το πεδίο VList που είναι μία VirusList η οποία περιέχει όλους τους ιούς που έχουν εισαχθεί στην εφαρμογή μαζί με το 1 BloomFilter και τις 2 SkipLists που συνοδεύουν τον κάθε ιό. Ακόμα, περιέχει το πεδίο CitizenList που είναι μία SkipList και αποθηκεύει όλους τους πολίτες που έχουν εισαχθεί στην εφαρμογή. Η CitizenList επιλέχθηκε να είναι τύπου SkipList επειδή είναι αποδοτική για τις αναζητήσεις και τις εισαγωγές που χρειάζονται και επειδή είχε υλοποιηθεί ήδη για χρήση στους εμβολιασμένους και μη-εμβολιασμένους πολίτες κάθε ιού.
Κατά τη δημιουργία ενός αντικειμένου VaccApp, δημιουργούνται και αρχικοποιούνται οι προαναφερθείσες δομές και έπειτα εισάγονται κατάλληλα οι εγγραφές από το αρχείο citizenRecordsFile στις παραπάνω δομές. Ανάλογα με τις εντολές που δίνονται στην εφαρμογή και τα ορίσματά τους, καλούνται(στη main συνάρτηση του vaccineMonitor.cpp που περιγράφεται παρακάτω) οι αντίστοιχες μέθοδοι της VaccApp. 
Ιδιαίτερα, οι διάφορες μέθοδοι populationStat και populationStatByAge εκτελούν την εξής διαδικασία. Δημιουργούν μία StatList και καλούν τις κατάλληλες UpdateStatList με τα κατάλληλα ορίσματα στις SkipList των vaccinated person και των not-vaccinated persons του ζητούμενου ιού. Κάθε UpdateStatList διασχίζει όλους τους πολίτες που είναι αποθηκευμένοι στην αντίστοιχη SkipList και ενημερώνει ανάλογα τη StatList. Στο τέλος η populationStat ή η populationStatByAge καλεί την επιθυμητή Print της StatList, τυπώνει τα στατιστικά και η StatList καταστρέφεται.

Τέλος, το αρχείο vaccineMonitor.cpp περιέχει τη main συνάρτηση. Αυτή, αρχικά δημιουργεί ένα αντικείμενο VaccApp δίνοντας ως παράμετρο τον αριθμό 3000000000 ως έναν ενδεικτικό αριθμό μέγιστου προσδοκώμενου αριθμού ατόμων που θα εισαχθεί στην εφαρμογή. Όπως, αναφέρθηκε παραπάνω, αυτός ο αριθμός δεν περιορίζει στην πραγματικότητα τον αριθμό των ατόμων που μπορούν εισαχθούν, αλλά υπολογίζει απλώς ένα ανώτατο όριο στο ύψος(=αριθμός επιπέδων-1) της κάθε SkipList έτσι ώστε αυτές να παραμένουν αποδοτικές και να μην αυξηθεί σε ακραίες περιπτώσεις ο αριθμός των επιπέδων ανεξέλεγκτα. Αφού δημιουργηθεί το VaccApp με τις εγγραφές του αρχείου, το πρόγραμμα διαβάζει εντολές από το χρήστη και κάνοντας τους κατάλληλους ελέγχους, εκτυπώνει τυχόν μηνύματα σφάλματος και καλεί την αντίστοιχη μέθοδο της VaccApp. 

Το bash script:
Η συνάρτηση GenRandFnLnCAge του script παράγει τυχαία, ένα ονοματεπώνυμο, μια χώρα και μια ηλικία με τον τρόπο που περιγράφεται στην εκφώνηση. Αντίστοιχα, η GenRandVirY_NDate επιλέγει τυχαία έναν ιό, παράγει τυχαία τη λέξη YES ή NO και στην περίπτωση του YES παράγει και μια ημερομηνία. Στην περίπτωση του NO με πιθανότητα 90% δεν παράγει ημερομηνία και με πιθανότητα 10% παράγει. Με τη βοήθεια αυτών των συναρτήσεων το script παράγει στο αρχείο τυχαία τις εγγραφές. 
Στην περίπτωση όπου το duplicatesAllowed έχει τιμή 0, για την παραγωγή των IDs δημιουργείται αρχικά ένα array (allNUMBERS) με όλους τους αριθμούς από 1 έως 9999. Για κάθε record επιλέγεται ως ID ένας τυχαίος αριθμός στο array από τους αχρησιμοποίητους(αυτοί βρίσκονται στο "πρώτο μέρος" του array). Στο array αυτός ο αριθμός αντικαθίσταται από τον τελευταίο αχρησιμοποίητο και με αυτόν τον τρόπο το αρχικό κομμάτι του array περιέχει πάντα όλους τους αριθμούς που δεν έχουν χρησιμοποιηθεί ακόμα. Έτσι, επιλέγεται πάντα τυχαίο ID που δεν έχει χρησιμοποιηθεί και το script παραμένει αποδοτικό, αποφεύγοντας να διαβάζουμε κάθε φορά όλα τα IDs που έχουν χρησιμοποιηθεί για να επιλέξουμε ένα νέο. 
Στην περίπτωση που το duplicatesAllowed δεν έχει τιμή 0, για κάθε νέα εγγραφή που δημιουργούμε επιλέγουμε τυχαία αν έχει duplicate ID ή όχι(περίπου 90% δεν είναι duplicate, 10% είναι. Η πιθανότητα για duplicate όμως αυξάνεται σημαντικά, όσο αυξάνεται ο αριθμός των γραμμών). Παράλληλα διατηρούμε το πλήθος εγγραφών που αναφέρονται σε duplicate citizen και αν ο αριθμός αυτός πέσει κάτω από το 5%, επιβάλουμε η επόμενη εγγραφή να έχει duplicate ID άσχετα από την τυχαία επιλογή μας. Έτσι διατηρείται πάντα ένας ικανοποιητικός αριθμός από duplicates. Αν η νέα εγγραφή επιλεγεί να έχει duplicate ID, επιλέγουμε τυχαία αν όλα τα στοιχεία του πολίτη θα είναι duplicate(δηλαδή αν η εγγραφή αφορά πολίτη προηγούμενης εγγραφής) ή αν μόνο το ID θα είναι duplicate(δηλαδή θα έχουμε  inconsistent εγγραφή). Με 90% επιλέγεται να είναι duplicate όλος ο citizen και με 10% μόνο το ID. Για την παραγωγή του duplicate επιλέγουμε τυχαία μία από τις προηγούμενες εγγραφές.

Ελευθέριος Μπόλκας 1115201900353

Περιεχόμενα:
Ένας φάκελος input_dir με τη δομή που αναφέρεται στην εκφώνηση, το README.txt, το Makefile, τα αρχεία πηγιαίου κώδικα:
travelMonitorClient.cpp: Περιέχει τη main για το travelMonitorClient 
monitorServer.cpp: Περιέχει τη main για το monitorServer 
και οι φάκελοι:
AppTravelMonitor: Περιέχει το AppTravelMonitor.cpp με το header του στα οποία ορίζεται μια αντίστοιχη κλάση που υλοποιεί όλη την κυρίως λειτουργία 
του travelMonitorClient.
AppMonitor: Περιέχει το AppMonitor.cpp με το header του στα οποία ορίζεται μια αντίστοιχη κλάση που υλοποιεί όλη την κυρίως λειτουργία του 
monitorServer.
MessageExchange: Περιέχει το messageExchange.cpp με το header του που υλοποιεί συναρτήσεις για ανταλλαγή μηνυμάτων μέσω socket και με χρήση του 
buffer
BloomFilter: Περιέχει το bloomfilter.cpp με το header του που υλοποιεί το BloomFilter
Date_citizen: Περιέχει το date_citizen.cpp με το header του που ορίζει κλάσεις για date και citizen
HelpfulFunctions: Περιέχει το helpfulStringFunctions.cpp με το header του που περιέχει βοηθητικές συναρτήσεις για strings
OtherLists: Περιέχει τα namesList.cpp, statList.cpp, virusList.cpp με τα header τους που υλοποιούν διάφορων ειδών λίστες
SkipList: Περιέχει το skiplist.cpp με το header του που υλοποιεί την SkipList

Compilation της εφαρμογής:
Από το κεντρικό directory στο οποίο βρίσκεται και το Makefile εκτελούμε την make. Γίνεται separate compilation και στο τέλος μέσω του linker 
δημιουργούνται τα εκτελέσιμα travelMonitorClient και monitorServer.

Εκτέλεση προγράμματος:
./travelMonitorClient -m numMonitors -b socketBufferSize -c cyclicBufferSize -s sizeOfBloom -i input_dir -t numThreads

Η εφαρμογή:
Πρωτόκολλα ανταλλαγής μηνυμάτων μέσω socket:
Τα πρωτόκολλα που ακολουθούνται για την ανταλλαγή μηνυμάτων είναι ίδια ουσιαστικά με αυτά της 2ης εργασίας με τη διαφορά ότι η επικοινωνία γίνεται 
μέσω sockets. Ξαναγράφω κι εδώ το βασικό πρωτόκολλο:
Όλα τα μηνύματα μεταξύ Parent process και Monitors ανταλλάσσονται με τον τρόπο που περιγράφεται εδώ. Για την ανταλλαγή των μηνυμάτων 
χρησιμοποιούνται οι συναρτήσεις που βρίσκονται στα αρχεία messageExchange.cpp, messageExchange.h. Εκεί ορίζονται η συνάρτηση GetMessage για την 
παραλαβή ενός μηνύματος και η συνάρτηση SendMessage για την αποστολή ενός μηνύματος. Και οι δύο συναρτήσεις στα ορίσματά τους παίρνουν ένα buffer 
με το bufferSize που χρησιμοποιείται για να γραφτεί και να διαβαστεί ένα μήνυμα(το buffer έχει φτιαχτεί στο travelMonitorClient και στο 
monitorServer). Επίσης, παίρνουν στα ορίσματα έναν socket descriptor που είναι το socket από το οποίο διαβάζεται και στέλνεται το μήνυμα 
αντίστοιχα. Κάθε μήνυμα που στέλνεται και διαβάζεται είναι τύπου δείκτης σε char. Η ερμηνεία του μηνύματος και η συνολική επικοινωνία μεταξύ parent 
και child process μπορεί να χρησιμοποιούν επιπλέον πρωτόκολλα(τα οποία έχουν αναλυθεί στο README.txt της 2ης εργασίας), ωστόσο πάντα η αποστολή 
ενός μηνύματος και η λήψη του μηνύματος ακολουθεί το πρωτόκολλο που αναλύεται εδώ και υλοποιείται από αυτές τις δύο συναρτήσεις. Για την αποστολή 
του μηνύματος, προστίθενται στην αρχή του 10 επιπλέον bytes που υποδεικνύουν το μέγεθος του αρχικού μηνύματος. Συγκεκριμένα κάθε byte είναι ένας 
αριθμός τύπου char που αναπαριστά ένα ψηφίο του μέγεθους του αρχικού μηνύματος. Το νέο μήνυμα που δημιουργείται χωρίζεται σε τμήματα έτσι ώστε κάθε 
τμήμα να μπορεί να χωρέσει στο buffer και ένα-ένα τα τμήματα αντιγράφονται στο buffer και γράφονται στο socket. Για τη λήψη του μηνύματος, αρχικά 
διαβάζονται τα πρώτα 10 bytes(σταδιακά στην περίπτωση που το buffer είναι μικρό), αποκωδικοποιείται το μέγεθος του υπόλοιπου μηνύματος και γίνεται 
allocate στο heap μνήμη όση το μέγεθος του μηνύματος. Έπειτα διαβάζονται από το socket το πολύ bufferSize bytes κάθε φορά στο buffer και αυτά 
αντιγραφόνται με τη σειρά στη μνήμη που κάναμε allocate. Όταν διαβαστεί όλο το μήνυμα, επιστρέφεται(μέσω της μεταβλητής Message των ορισμάτων της 
GetMessage, που είναι reference σε δείκτη σε char) αυτή η ένωση όλων των τμημάτων που διαβάστηκαν και αποτελεί το αρχικό μήνυμα που στάλθηκε. 
Επισημαίνεται ότι κατά τη διάρκεια τόσο της read όσο και της write αναγνωρίζεται ο πραγματικός αριθμός των bytes που διαβάστηκαν ή γράφτηκαν, έτσι 
ώστε αν δεν διαβάστηκε/γράφτηκε ο αναμενόμενος αριθμός από bytes λόγω interruption από κάποιο σήμα, η διαδικασία να συνεχίζεται από εκεί που είχε 
μείνει χωρίς πρόβλημα.

Γενικές πληροφορίες για κάποιες κλάσεις:
Οι κλάσεις BloomFilter, SkipList, date, citizen, VirusList, NamesList, ListOfLists, StatList είναι ίδιες με αυτές που υλοποιήθηκαν στη δεύτερη 
εργασία και αναπαριστούν τα αντίστοιχα αντικείμενα. 

Ανάλυση της υλοποίησης του travelMonitorClient:
Αφού γίνουν οι απαραίτητοι έλεγχοι, στην main(travelMonitorClient.cpp) δημιουργείται ένα αντικείμενο της κλάσης AppTravelMonitor στην οποία 
υλοποιούνται ουσιαστικά όλες οι λειτουργίες της εφαρμογής. Η κλάση AppTravelMonitor έχει τα ίδια μέλη πεδία με την ίδια κλάση της 2ης εργασίας με 
τη διαφορά πως αντί για file descriptors για named pipes έχει ένα πίνακα για τους socket descriptors των sockets από τα οποία διαβάζει και γράφει 
μηνύματα. Ο constructor και οι μέθοδοι της κλάσης υλοιποιούν όλες τις ζητούμενες λειτουργίες όπως και στην δεύτερη εργασία με τις διαφορές που 
αναφέρονται στην εκφώνηση. Η επικοινωνία εδώ γίνεται μέσω sockets, έχοντας ένα socket για κάθε monitorServer το οποίο χρησιμοποιείται και για την 
αποστολή και για τη λήψη μηνυμάτων. Στον constructor δημιουργούνται τα sockets και σε κάθε ένα από αυτά επιχειρείται μέσω της connect μία TCP 
σύνδεση με το αντίστοιχο monitorServer. Το connect ξαναεπιχειρείται μέχρι να επιτύχει, καθώς το monitorServer μπορεί να αρχίσει να κάνει listen πιο 
μετά. Για τα ports που περνιούνται στα ορίσματα των execv και στα οποία ακούει από ένα monitorServer, επιλέγονται τυχαία numMonitors διαδοχικοί 
αριθμοί στο διάστημα [6001,9499+numMonitors].

Ανάλυση της υλοποίησης του monitorServer:
Στην main(monitorServer.cpp) δημιουργείται ένα socket, το οποίο χρησιμοποείται για να ακούει το monitorServer περιμένοντας συνδέσεις, και 
δημιουργείται ένα αντικείμενο της κλάσης AppMonitor στην οποία υλοποιείται όλη η λειτουργία του Monitor. Η κλάση αυτή, με εξαίρεση τις διαφορές που 
αναλύονται παρακάτω, έχει κι αυτή τα ίδια πεδία με την αντίστοιχη της 2ης εργασίας και ο constructor και οι μέθοδοί της υλοιποιούν όλες τις 
ζητούμενες λειτουργίες όπως και στην δεύτερη εργασία με τις διαφορές που αναφέρονται στην εκφώνηση. Η επικοινωνία γίνεται μέσω socket και το πεδίο 
Socket είναι ο descriptor που χρησιμοποιείται για διάβασμα και γράψιμο στην επικοινωνία με το parent process. Στον constructor γίνεται bind το 
αρχικό socket, μετά listen και όταν γίνει accept το connection με το parent process επιστρέφεται ο descriptor Socket που αναφέρθηκε.

Στην κλάση AppMonitor περιλαμβάνεται επιπλέον, ως εμφωλευμένη κλάση, η CyclicBuffer που υλοποιεί τον κυκλικό buffer. Περιέχει ένα πίνακα από 
ονόματα, το μέγεθός του και από μία ένδειξη για το πρώτο και το τελευταίο στοιχείο που χρησιμοποιείται σε αυτό το buffer μια δεδομένη στιγμή. 
Υπάρχουν επίσης οι μέθοδοί του που ελέγχουν αν είναι άδειος, προσθέτουν ένα αρχείο και αφαιρούν ένα αρχείο. Στα πεδία οπότε της AppMonitor υπάρχει 
ένα τέτοιο αντικείμενο για το κυκλικό buffer, καθώς και τα πεδία ExitNow και PossibleProcessing. Το ExitNow χρησιμεύει για να ελέγχουν τα threads 
αν πρέπει να τερματίσουν και το PossibleProcessing για να ελέγχει το αρχικό thread αν έχει τελειώσει η επεξεργασία των αρχείων και η εισαγωγή στις 
δομές, ώστε να σταλούν τα BloomFilters. Το πεδίο tids είναι ένας πίνακας που αποθηκεύει τα ids των νέων threads.

Μέσα στον constructor της AppMonitor δημιουργούνται τα νέα threads τα οποία ξεκινούν με τη συνάρτηση threadOperation και στην οποία τα threads 
διαβάζουν τα αρχεία από το cyclic buffer και ενημερώνουν τις διάφορες δομές. Όταν δεν υπάρχει αρχείο στο cyclic buffer, περιμένουν μέχρι να μπει 
κάποιο ή μέχρι να χρειαστεί να τερματίσουν. Η μέθοδος GetFilesUpdateCyclBufferCondWait που χρησιμοποιείται από το αρχικό thread και στον 
constructor για την αρχική ενημέρωση των δομών και όταν λαμβάνεται η εντολή /addVaccinationRecords, βάζει τα νέα αρχεία στο cyclic 
buffer(περιμένοντας πιθανόν αν γεμίσει ο buffer να ελευθερωθεί χώρος για να συνεχίσει) και περιμένει διαβαστούν από τα threads όλα τα αρχεία στο 
cyclic buffer και να ενημερωθούν οι αντίστοιχες δομές. Η μέθοδος ExitApp αλλάζοντας το flag ExitNow και με κατάλληλο σήμα ενημερώνει τα threads ότι 
πρέπει να τερματίσουν και τα περιμένει να επιστρέψουν.

Τα mutexes και τα condition variables που χρησιμοποιούνται ορίζονται ως global μεταβλητές. Έχουν οριστεί 3 mutexes, το ExitMtx για να προστατεύεται 
η πρόσβαση στο ExitNow, το CyclBufMtx για να προστατεύεται η πρόσβαση στον κυκλικό buffer και το InsertFromFileMtx για να προστατεύεται η μεταβλητή 
PossibleProcessing καθώς και οι διάφορες δομές όταν αυτές ανανεώνονται από τα threads. Επίσης, έχουν οριστεί 3 condition variables. Στο 
NotEmptyBufOrExitCond περιμένουν τα threads μέχρι να μπει ένα αρχείο στο cyclic buffer ή το ExitNow να γίνει true και να ενημερωθούν ότι πρέπει να 
τερματίσουν. Στο NotFullBufCond περιμένει το αρχικό thread να ελευθερωθεί χώρος στο cyclic buffer ώστε να προσθέσει κάποιο αρχείο. Στο 
ProcessingDoneCond περιμένει το αρχικό thread να τελειώσουν τα άλλα threads την ενημέρωση των δομών(αυτό γίνεται όταν έχει αδειάσει ο cyclic buffer 
και το PossibleProcessing έχει τιμή 0) ώστε να μπορεί μετά να στείλει τα BloomFilters. 

Τα mutexes και τα condition variables χρησιμοποιούνται κατάλληλα(με τον τρόπο που αναλύεται στα σχόλια του κώδικα) ώστε να υπάρχει συγχρονισμός 
όπου αυτό είναι απαραίτητο. Επισημαίνεται ότι σε όλα τα παραπάνω έχει ληφθεί υπόψη το ενδεχόμενο που αναφέρεται στο manual να επιστρέψει μια κλήση 
cond_wait χωρίς να ληφθεί κάποιο signal(spurious wakeups). Για να αντιμετωπιστεί αυτό έχουν προστεθεί κατάλληλοι έλεγχοι συνθηκών και χρήση locks, 
cond_waits και cond_signals των παραπάνω mutexes και condition variables ώστε ο συγχρονισμός να επιτυγχάνεται σε κάθε περίπτωση χωρίς προβλήματα. 
Τέλος, αναφέρεται ότι όταν το αρχικό thread δεν εκτελεί τη συνάρτηση GetFilesUpdateCyclBufferCondWait, τα υπόλοιπα threads είναι δυνατό να 
αποκτήσουν πρόσβαση μόνο στα ExitNow, PossibleProcessing και cyclic buffer, οπότε όταν το αρχικό thread εκτελεί κάποια άλλη μέθοδο, οι υπόλοιπες 
μεταβλητές και δομές δεν χρειάζεται να προστατευτούν με mutexes. 

